<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lily's Unicorns - Level Map</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #87CEEB 0%, #98E4FF 50%, #87CEEB 100%);
            font-family: monospace;
            color: #333;
            min-height: 100vh;
            overflow: hidden;
        }
        
        .map-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .map-canvas {
            position: relative;
            width: 800px;
            height: 600px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            overflow: hidden;
        }
        
        .diamond {
            position: absolute;
            width: 36px;
            height: 36px;
            background: linear-gradient(45deg, #FFD700, #FFA500);
            transform: rotate(45deg);
            border: 2px solid #fff;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }
        
        .diamond:hover {
            transform: rotate(45deg) scale(1.2);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
            background: linear-gradient(45deg, #FFE55C, #FFB347);
        }
        
        .diamond.completed {
            background: linear-gradient(45deg, #4CAF50, #45a049);
        }
        
        .diamond.perfect {
            background: linear-gradient(45deg, #9C27B0, #7B1FA2);
        }
        
        .diamond.incomplete {
            background: linear-gradient(45deg, #FF9800, #F57C00);
        }
        
        .diamond.locked {
            background: linear-gradient(45deg, #999, #666);
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        .diamond.current {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            animation: pulse 2s infinite;
        }
        
        .diamond.selected {
            border: 4px solid #4A90E2;
            box-shadow: 0 0 20px rgba(74, 144, 226, 0.6);
        }
        
        @keyframes pulse {
            0%, 100% { transform: rotate(45deg) scale(1); }
            50% { transform: rotate(45deg) scale(1.1); }
        }
        
        .diamond-label {
            position: absolute;
            color: #fff;
            font-weight: bold;
            font-size: 14px;
            transform: rotate(-45deg);
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            pointer-events: none;
        }
        
        .connection-line {
            position: absolute;
            height: 3px;
            background: linear-gradient(90deg, rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0.4));
            z-index: 1;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            border-radius: 2px;
        }
        
        .title {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 2em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            z-index: 20;
        }
        
        .back-button {
            position: absolute;
            top: 20px;
            left: 20px;
            background: linear-gradient(45deg, #4A90E2, #357ABD);
            color: white;
            border: none;
            padding: 10px 20px;
            font-family: monospace;
            border-radius: 15px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            z-index: 20;
        }
        
        .back-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }
        
        .level-info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 25px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            text-align: center;
            z-index: 20;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }
        
        .level-info.show {
            opacity: 1;
            pointer-events: all;
        }
        
        .level-info.persistent {
            opacity: 1;
            pointer-events: all;
            background: rgba(255, 255, 255, 0.98);
            border: 2px solid #4A90E2;
        }
        
        .mobile-warning {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #87CEEB 0%, #98E4FF 50%, #87CEEB 100%);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
        }
        
        .mobile-warning-content {
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            font-family: monospace;
        }
        
        .legend {
            position: absolute;
            top: 80px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            font-family: monospace;
            font-size: 12px;
            z-index: 15;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        
        .legend-diamond {
            width: 16px;
            height: 16px;
            transform: rotate(45deg);
            margin-right: 12px;
            border: 1px solid #333;
        }
        
        .level-preview {
            position: absolute;
            top: 400px;
            left: 20px;
            width: 250px;
            height: 180px;
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid #4A90E2;
            border-radius: 8px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            padding: 8px;
            box-sizing: border-box;
        }
        
        .level-preview.show {
            opacity: 1;
        }
        
        .level-preview canvas {
            width: 100%;
            height: 150px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: #87CEEB;
        }
        
        .level-preview-title {
            font-size: 12px;
            font-weight: bold;
            color: #333;
            text-align: center;
            margin-bottom: 4px;
        }
        
        @media (max-width: 768px) {
            .mobile-warning {
                display: flex;
            }
            .map-container {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="mobile-warning">
        <div class="mobile-warning-content">
            <div style="font-size: 3em; margin: 20px 0;">ü¶Ñ</div>
            <h2 style="color: #4A90E2;">Computer Required</h2>
            <p>Level selection is designed for desktop use.</p>
            <div>
                <a href="index.html" style="color: #4A90E2; text-decoration: none; font-weight: bold;">‚Üê Back to Game</a>
            </div>
        </div>
    </div>

    <div class="map-container">
        <div class="title">ü¶Ñ Level Map üåà</div>
        
        <button class="back-button" onclick="goBack()">‚Üê Back to Game</button>
        
        <button class="back-button" onclick="resetProgress()" style="top: 20px; right: 20px; left: auto; background: linear-gradient(45deg, #e74c3c, #c0392b);">üîÑ Reset Progress</button>
        
        <div class="legend">
            <h4 style="margin-top: 0; color: #333;">Legend:</h4>
            <div class="legend-item">
                <div class="legend-diamond" style="background: linear-gradient(45deg, #4CAF50, #45a049); animation: pulse 2s infinite;"></div>
                <span>Current Level</span>
            </div>
            <div class="legend-item">
                <div class="legend-diamond" style="background: linear-gradient(45deg, #9C27B0, #7B1FA2);"></div>
                <span>Perfect Score (üíú)</span>
            </div>
            <div class="legend-item">
                <div class="legend-diamond" style="background: linear-gradient(45deg, #FF9800, #F57C00);"></div>
                <span>Incomplete (üß°)</span>
            </div>
            <div class="legend-item">
                <div class="legend-diamond" style="background: linear-gradient(45deg, #999, #666);"></div>
                <span>Locked</span>
            </div>
        </div>
        
        <div class="map-canvas" id="mapCanvas">
            <!-- Diamonds and connections will be generated by JavaScript -->
        </div>
        
        <div class="level-info" id="levelInfo">
            <h3 id="levelTitle">Level 1</h3>
            <p id="levelDescription">The beginning of your magical journey!</p>
            <button onclick="playLevel()" style="background: #4CAF50; color: white; border: none; padding: 8px 16px; border-radius: 8px; cursor: pointer;">Play Level</button>
        </div>
        
        <div class="level-preview" id="levelPreview">
            <div class="level-preview-title" id="previewTitle">Level 1</div>
            <canvas id="previewCanvas" width="230" height="140"></canvas>
        </div>
    </div>

    <script>
        // Progress tracking system (shared with game.js)
        class ProgressManager {
            static getProgress() {
                try {
                    const progress = localStorage.getItem('lily_unicorns_progress');
                    return progress ? JSON.parse(progress) : { completedLevels: [], currentLevel: 1 };
                } catch (error) {
                    console.warn('Failed to load progress:', error);
                    return { completedLevels: [], currentLevel: 1 };
                }
            }
            
            static saveProgress(progress) {
                try {
                    localStorage.setItem('lily_unicorns_progress', JSON.stringify(progress));
                } catch (error) {
                    console.warn('Failed to save progress:', error);
                }
            }
            
            static getCurrentLevel() {
                return this.getProgress().currentLevel;
            }
            
            static getCompletedLevels() {
                return this.getProgress().completedLevels;
            }
            
            static isLevelCompleted(level) {
                return this.getCompletedLevels().includes(level);
            }
            
            static isLevelPerfect(level) {
                const progress = this.getProgress();
                return progress.levelScores && progress.levelScores[level] === true;
            }
            
            static getLevelScore(level) {
                const progress = this.getProgress();
                if (!progress.levelScores || progress.levelScores[level] === undefined) {
                    return null; // Not completed yet
                }
                return progress.levelScores[level]; // true for perfect, false for incomplete
            }
            
            static resetProgress() {
                this.saveProgress({ completedLevels: [], currentLevel: 1, levelScores: {} });
            }
        }

        class LevelMap {
            constructor() {
                this.mapCanvas = document.getElementById('mapCanvas');
                this.currentLevel = ProgressManager.getCurrentLevel();
                this.completedLevels = ProgressManager.getCompletedLevels();
                this.maxLevels = 12; // Will be detected later
                this.selectedLevel = this.currentLevel;
                this.levelPositions = {};
                this.connections = [];
                this.levelNames = {}; // Cache for level names
                
                this.init();
            }
            
            async init() {
                await this.detectMaxLevels();
                await this.loadLevelNames();
                this.generateLevelPositions();
                this.createConnections();
                this.renderMap();
                this.setupEventListeners();
            }
            
            async detectMaxLevels() {
                // Initialize with embedded data levels if available
                this.availableLevels = [];
                
                if (typeof LEVEL_DATA !== 'undefined') {
                    const embeddedLevels = Object.keys(LEVEL_DATA).map(k => parseInt(k)).filter(n => !isNaN(n));
                    this.availableLevels = [...embeddedLevels];
                }
                
                // Use a smart scanning approach that minimizes 404s
                this.availableLevels = await this.scanForLevels();
                
                // Sort and set max level
                this.availableLevels.sort((a, b) => a - b);
                this.maxLevels = this.availableLevels.length > 0 ? Math.max(...this.availableLevels) : 1;
                
                console.log(`Level map detected available levels: [${this.availableLevels.join(', ')}]`);
                console.log(`Max level: ${this.maxLevels}`);
            }
            
            async scanForLevels() {
                const foundLevels = new Set();
                
                // Add any embedded levels first
                if (typeof LEVEL_DATA !== 'undefined') {
                    const embeddedLevels = Object.keys(LEVEL_DATA).map(k => parseInt(k)).filter(n => !isNaN(n));
                    embeddedLevels.forEach(level => foundLevels.add(level));
                }
                
                // Scan systematically with minimal requests
                // Check levels 1-50 in batches to find existing ones efficiently
                let consecutiveNotFound = 0;
                const maxConsecutiveNotFound = 3;
                
                for (let level = 1; level <= 50; level++) {
                    try {
                        const response = await fetch(`levels/level${level}.json`, {
                            method: 'HEAD',
                            cache: 'no-store',
                            headers: { 'Cache-Control': 'no-cache' }
                        });
                        
                        if (response.ok) {
                            foundLevels.add(level);
                            consecutiveNotFound = 0;
                        } else {
                            consecutiveNotFound++;
                            // If we haven't found anything in a while and we have some levels, stop
                            if (consecutiveNotFound >= maxConsecutiveNotFound && foundLevels.size > 0) {
                                break;
                            }
                        }
                    } catch (error) {
                        consecutiveNotFound++;
                        // If we haven't found anything in a while and we have some levels, stop
                        if (consecutiveNotFound >= maxConsecutiveNotFound && foundLevels.size > 0) {
                            break;
                        }
                    }
                    
                    // Add a small delay to be gentle on the server
                    await new Promise(resolve => setTimeout(resolve, 10));
                }
                
                return Array.from(foundLevels);
            }
            
            async loadLevelNames() {
                // Load level names from JSON files
                for (let level = 1; level <= this.maxLevels; level++) {
                    try {
                        const levelData = await this.loadLevelData(level);
                        if (levelData && levelData.level && levelData.level.name) {
                            this.levelNames[level] = levelData.level.name;
                        } else {
                            this.levelNames[level] = `Level ${level}`;
                        }
                    } catch (error) {
                        this.levelNames[level] = `Level ${level}`;
                    }
                }
            }
            
            generateLevelPositions() {
                // Create a winding path layout like a game board
                const pathPoints = this.generatePathPoints();
                
                for (let level = 1; level <= this.maxLevels; level++) {
                    if (pathPoints[level - 1]) {
                        this.levelPositions[level] = pathPoints[level - 1];
                    }
                }
            }
            
            generatePathPoints() {
                const points = [];
                const margin = 80;
                const canvasWidth = 800;
                const canvasHeight = 600;
                const spacing = 90;
                
                // Create a winding path that fills the canvas nicely
                let x = margin;
                let y = margin;
                let direction = 1; // 1 for right, -1 for left
                let level = 0;
                
                while (y < canvasHeight - margin && level < 100) {
                    // Add points going horizontally
                    while ((direction === 1 && x < canvasWidth - margin) || 
                           (direction === -1 && x > margin)) {
                        points.push({ x, y });
                        x += spacing * direction;
                        level++;
                        
                        if (level >= 100) break;
                    }
                    
                    // Move to next row
                    y += spacing;
                    direction *= -1; // Reverse direction for next row
                    
                    // Adjust x position for the new row
                    if (direction === 1) {
                        x = margin;
                    } else {
                        x = canvasWidth - margin;
                    }
                }
                
                return points;
            }
            
            createConnections() {
                this.connections = [];
                
                // Create connections between consecutive levels
                for (let level = 2; level <= this.maxLevels; level++) {
                    const prevLevel = level - 1;
                    if (this.levelPositions[prevLevel] && this.levelPositions[level]) {
                        this.connections.push({
                            from: prevLevel,
                            to: level,
                            fromPos: this.levelPositions[prevLevel],
                            toPos: this.levelPositions[level]
                        });
                    }
                }
            }
            
            renderMap() {
                // Clear existing content
                this.mapCanvas.innerHTML = '';
                
                // Render connections first (behind diamonds)
                this.connections.forEach(conn => {
                    this.renderConnection(conn);
                });
                
                // Render diamonds
                for (let level = 1; level <= this.maxLevels; level++) {
                    if (this.levelPositions[level]) {
                        this.renderDiamond(level, this.levelPositions[level]);
                    }
                }
            }
            
            renderConnection(connection) {
                const line = document.createElement('div');
                line.className = 'connection-line';
                
                const dx = connection.toPos.x - connection.fromPos.x;
                const dy = connection.toPos.y - connection.fromPos.y;
                const angle = Math.atan2(dy, dx);
                
                // Calculate connection points at diamond edges
                const diamondRadius = 25; // Approximate radius to edge of rotated diamond
                const startX = connection.fromPos.x + Math.cos(angle) * diamondRadius;
                const startY = connection.fromPos.y + Math.sin(angle) * diamondRadius;
                const endX = connection.toPos.x - Math.cos(angle) * diamondRadius;
                const endY = connection.toPos.y - Math.sin(angle) * diamondRadius;
                
                // Calculate actual line length between diamond edges
                const actualDx = endX - startX;
                const actualDy = endY - startY;
                const length = Math.sqrt(actualDx * actualDx + actualDy * actualDy);
                
                line.style.width = `${length}px`;
                line.style.left = `${startX}px`;
                line.style.top = `${startY}px`;
                line.style.transform = `rotate(${angle}rad)`;
                line.style.transformOrigin = 'left center';
                
                this.mapCanvas.appendChild(line);
            }
            
            renderDiamond(level, position) {
                const diamond = document.createElement('div');
                diamond.className = 'diamond';
                diamond.style.left = `${position.x - 18}px`; // Center the smaller diamond
                diamond.style.top = `${position.y - 18}px`;
                diamond.dataset.level = level;
                
                // Add status classes based on actual progress
                const isCompleted = this.completedLevels.includes(level);
                const isLocked = level > this.currentLevel;
                const levelScore = ProgressManager.getLevelScore(level);
                
                if (level === this.currentLevel && !isCompleted) {
                    diamond.classList.add('current');
                } else if (isCompleted) {
                    if (levelScore === true) {
                        diamond.classList.add('perfect'); // Purple - all items collected
                    } else if (levelScore === false) {
                        diamond.classList.add('incomplete'); // Orange - missed some items
                    } else {
                        diamond.classList.add('completed'); // Green - completed before scoring system
                    }
                } else if (isLocked) {
                    diamond.classList.add('locked');
                }
                
                // Add label
                const label = document.createElement('div');
                label.className = 'diamond-label';
                label.textContent = level;
                diamond.appendChild(label);
                
                // Add click handler - either play level directly or show info
                diamond.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (isLocked) {
                        this.showLevelInfo(level, true);
                        return;
                    }
                    
                    // Double-click or already selected level plays immediately
                    if (this.selectedLevel === level) {
                        this.playSelectedLevel();
                    } else {
                        this.selectLevel(level, true);
                    }
                });
                
                // Hover behavior for preview
                diamond.addEventListener('mouseenter', (e) => {
                    if (this.selectedLevel !== level) {
                        this.showLevelInfo(level, false);
                    }
                    this.showLevelPreview(level, e.target);
                });
                
                diamond.addEventListener('mouseleave', () => {
                    if (!this.levelInfoPersistent) {
                        this.hideLevelInfo();
                    }
                    this.hideLevelPreview();
                });
                
                this.mapCanvas.appendChild(diamond);
            }
            
            selectLevel(level, persistent = false) {
                this.selectedLevel = level;
                this.showLevelInfo(level, persistent);
                
                // Update diamond visual selection
                this.updateDiamondSelection();
            }
            
            showLevelInfo(level, persistent = false) {
                const levelInfo = document.getElementById('levelInfo');
                const levelTitle = document.getElementById('levelTitle');
                const levelDescription = document.getElementById('levelDescription');
                
                // Update title with score status
                const levelScore = ProgressManager.getLevelScore(level);
                let titleText = this.levelNames[level] || `Level ${level}`;
                
                if (levelScore === true) {
                    titleText += ' üíú Perfect!';
                } else if (levelScore === false) {
                    titleText += ' üß° Incomplete';
                } else if (this.completedLevels.includes(level)) {
                    titleText += ' ‚úÖ Completed';
                }
                
                levelTitle.textContent = titleText;
                levelDescription.textContent = this.getLevelDescription(level, levelScore);
                
                // Update play button based on level status
                const playButton = levelInfo.querySelector('button');
                const isCompleted = this.completedLevels.includes(level);
                const isLocked = level > this.currentLevel;
                
                if (isLocked) {
                    playButton.textContent = 'Locked Level';
                    playButton.style.background = '#999';
                    playButton.style.cursor = 'not-allowed';
                    playButton.onclick = null;
                } else if (isCompleted) {
                    playButton.textContent = 'Replay Level';
                    playButton.style.background = '#4CAF50';
                    playButton.style.cursor = 'pointer';
                    playButton.onclick = () => this.playSelectedLevel();
                } else if (level === this.currentLevel) {
                    playButton.textContent = 'Continue Level';
                    playButton.style.background = '#ff6b6b';
                    playButton.style.cursor = 'pointer';
                    playButton.onclick = () => this.playSelectedLevel();
                } else {
                    playButton.textContent = 'Play Level';
                    playButton.style.background = '#4CAF50';
                    playButton.style.cursor = 'pointer';
                    playButton.onclick = () => this.playSelectedLevel();
                }
                
                levelInfo.classList.add('show');
                if (persistent) {
                    levelInfo.classList.add('persistent');
                    this.levelInfoPersistent = true;
                } else {
                    levelInfo.classList.remove('persistent');
                    this.levelInfoPersistent = false;
                }
                
                this.selectedLevel = level;
            }
            
            hideLevelInfo() {
                const levelInfo = document.getElementById('levelInfo');
                levelInfo.classList.remove('show', 'persistent');
                this.levelInfoPersistent = false;
            }
            
            updateDiamondSelection() {
                // Remove previous selection highlights
                this.mapCanvas.querySelectorAll('.diamond').forEach(diamond => {
                    diamond.classList.remove('selected');
                });
                
                // Add selection highlight to current diamond
                const selectedDiamond = this.mapCanvas.querySelector(`[data-level="${this.selectedLevel}"]`);
                if (selectedDiamond) {
                    selectedDiamond.classList.add('selected');
                }
            }
            
            playSelectedLevel() {
                if (this.selectedLevel && this.selectedLevel <= this.currentLevel) {
                    window.location.href = `index.html?level=${this.selectedLevel}`;
                }
            }
            
            getLevelDescription(level, levelScore = null) {
                const descriptions = {
                    1: "The beginning of your magical journey!",
                    2: "Navigate through the first challenges.",
                    3: "Trees and platforms await you.",
                    4: "Maze Runner - Find your way through!",
                    5: "Jumping puzzles and precision timing.",
                    6: "Advanced platforming challenges.",
                    7: "Dangerous swamps and careful navigation.",
                    8: "Complex multi-level structures.",
                    9: "Speed and agility required.",
                    10: "Master level precision needed."
                };
                
                let description = descriptions[level] || `Challenge level ${level} - Test your skills!`;
                
                // Add score-specific information
                if (levelScore === true) {
                    description += "\n\nüåü Perfect Score! You collected all the white and black items!";
                } else if (levelScore === false) {
                    description += "\n\n‚≠ê You completed this level but missed some items. Try again for a perfect score!";
                } else if (this.completedLevels.includes(level)) {
                    description += "\n\n‚úÖ Level completed! (Before scoring system was added)";
                }
                
                return description;
            }
            
            async showLevelPreview(level, diamondElement) {
                try {
                    const levelData = await this.loadLevelData(level);
                    if (!levelData) return;
                    
                    const preview = document.getElementById('levelPreview');
                    const previewTitle = document.getElementById('previewTitle');
                    const canvas = document.getElementById('previewCanvas');
                    
                    previewTitle.textContent = this.levelNames[level] || `Level ${level}`;
                    
                    // Render level preview
                    this.renderLevelPreview(canvas, levelData);
                    
                    preview.classList.add('show');
                } catch (error) {
                    console.warn(`Failed to load preview for level ${level}:`, error);
                }
            }
            
            hideLevelPreview() {
                const preview = document.getElementById('levelPreview');
                preview.classList.remove('show');
            }
            
            async loadLevelData(level) {
                try {
                    const response = await fetch(`levels/level${level}.json`, {
                        cache: 'no-store',
                        headers: { 'Cache-Control': 'no-cache' }
                    });
                    
                    if (response.ok) {
                        return await response.json();
                    }
                    
                    // Fallback to embedded data
                    if (typeof LEVEL_DATA !== 'undefined' && LEVEL_DATA[level]) {
                        return LEVEL_DATA[level];
                    }
                    
                    return null;
                } catch (error) {
                    // Try embedded data
                    if (typeof LEVEL_DATA !== 'undefined' && LEVEL_DATA[level]) {
                        return LEVEL_DATA[level];
                    }
                    throw error;
                }
            }
            
            renderLevelPreview(canvas, levelData) {
                const ctx = canvas.getContext('2d');
                const width = 230;
                const height = 140;
                
                // Clear canvas
                ctx.fillStyle = '#87CEEB';
                ctx.fillRect(0, 0, width, height);
                
                // Game canvas is 1280x720, we need to match that aspect ratio
                // Y coordinates in level data are percentages where 0% = top of screen, 100% = bottom
                const gameWidth = 1280;
                const gameHeight = 720;
                const scaleX = width / 100;   // Scale percentage to preview width
                const scaleY = height / 100;  // Scale percentage to preview height
                
                // Draw platforms
                if (levelData.platforms) {
                    levelData.platforms.forEach(platform => {
                        const alpha = (platform.alpha || 255) / 255;
                        ctx.fillStyle = `rgba(${platform.color[0]}, ${platform.color[1]}, ${platform.color[2]}, ${alpha})`;
                        
                        // Apply same coordinate transformation as the game: this.height - (this.height * (y / 100))
                        const x = (platform.x / 100) * width;
                        const y = height - ((platform.y / 100) * height);
                        const w = (platform.width / 100) * width;
                        const h = (platform.height / 100) * height;
                        
                        ctx.fillRect(x, y, w, h);
                    });
                }
                
                // Draw trees (trunk + foliage)
                if (levelData.trees) {
                    levelData.trees.forEach(tree => {
                        const x = (tree.x / 100) * width;
                        const y = height - ((tree.y / 100) * height);
                        const w = (tree.width / 100) * width;
                        const h = (tree.height / 100) * height;
                        
                        // Draw trunk (brown rectangle)
                        const trunkWidth = w * 0.3;
                        const trunkHeight = h * 0.7;
                        const trunkX = x + (w - trunkWidth) / 2;
                        const trunkY = y + h - trunkHeight; // From bottom of tree area
                        
                        ctx.fillStyle = '#8B4513';
                        ctx.fillRect(trunkX, trunkY, trunkWidth, trunkHeight);
                        
                        // Draw foliage (green circle)
                        const foliageRadius = w * 0.6 / 2;
                        const foliageX = x + w / 2;
                        const foliageY = y + h * 0.3; // From top portion of tree area
                        
                        ctx.fillStyle = '#228B22';
                        ctx.beginPath();
                        ctx.arc(foliageX, foliageY, foliageRadius, 0, Math.PI * 2);
                        ctx.fill();
                    });
                }
                
                // Draw clouds
                if (levelData.clouds) {
                    levelData.clouds.forEach(cloud => {
                        const alpha = (cloud.alpha || 180) / 255;
                        ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                        
                        const x = (cloud.x / 100) * width;
                        const y = height - ((cloud.y / 100) * height);
                        const w = (cloud.width / 100) * width;
                        const h = (cloud.height / 100) * height;
                        
                        ctx.fillRect(x, y, w, h);
                    });
                }
                
                // Draw triangles (spikes)
                if (levelData.triangles) {
                    levelData.triangles.forEach(triangle => {
                        ctx.fillStyle = `rgb(${triangle.color[0]}, ${triangle.color[1]}, ${triangle.color[2]})`;
                        
                        const x = (triangle.x / 100) * width;
                        const y = height - ((triangle.y / 100) * height);
                        const size = (triangle.size / 100) * Math.min(width, height);
                        
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(x + size/2, y - size);
                        ctx.lineTo(x + size, y);
                        ctx.closePath();
                        ctx.fill();
                    });
                }
                
                // Draw swamps
                if (levelData.swamps) {
                    levelData.swamps.forEach(swamp => {
                        ctx.fillStyle = '#2F4F2F';
                        
                        const x = (swamp.x / 100) * width;
                        const y = height - ((swamp.y / 100) * height);
                        const w = (swamp.width / 100) * width;
                        const h = (swamp.height / 100) * height;
                        
                        ctx.fillRect(x, y, w, h);
                    });
                }
                
                // Draw unicorns (starting positions)
                if (levelData.unicorns) {
                    Object.values(levelData.unicorns).forEach((unicorn, index) => {
                        ctx.fillStyle = index === 0 ? '#FF69B4' : '#98FB98';
                        ctx.beginPath();
                        
                        const x = (unicorn.x / 100) * width;
                        const y = height - ((unicorn.y / 100) * height);
                        
                        ctx.arc(x, y, 3, 0, 2 * Math.PI);
                        ctx.fill();
                    });
                }
                
                // Draw rainbow (goal) - horizontal bands like the game
                if (levelData.rainbow) {
                    const rainbow = levelData.rainbow;
                    // Apply same coordinate transformation as the game: this.width - (this.width * (x / 100))
                    const x = width - ((rainbow.x / 100) * width);
                    const y = height - ((rainbow.y / 100) * height);
                    const w = (rainbow.width / 100) * width;
                    const h = (rainbow.height / 100) * height;
                    
                    // Rainbow colors as horizontal bands
                    const colors = [
                        [255, 0, 0],    // Red
                        [255, 165, 0],  // Orange
                        [255, 255, 0],  // Yellow
                        [0, 255, 0],    // Green
                        [0, 0, 255],    // Blue
                        [75, 0, 130],   // Indigo
                        [238, 130, 238] // Violet
                    ];
                    
                    const bandHeight = h / colors.length;
                    
                    ctx.save();
                    ctx.globalAlpha = 0.7;
                    
                    colors.forEach((color, index) => {
                        ctx.fillStyle = `rgb(${color[0]}, ${color[1]}, ${color[2]})`;
                        ctx.fillRect(x, y + (index * bandHeight), w, bandHeight);
                    });
                    
                    ctx.restore();
                }
                
                // Draw collectible items
                if (levelData.white_items) {
                    ctx.fillStyle = '#FFFFFF';
                    levelData.white_items.forEach(item => {
                        const x = (item.x / 100) * width;
                        const y = height - ((item.y / 100) * height);
                        ctx.fillRect(x - 1, y - 1, 2, 2);
                    });
                }
                
                if (levelData.black_items) {
                    ctx.fillStyle = '#000000';
                    levelData.black_items.forEach(item => {
                        const x = (item.x / 100) * width;
                        const y = height - ((item.y / 100) * height);
                        ctx.fillRect(x - 1, y - 1, 2, 2);
                    });
                }
            }
            
            setupEventListeners() {
                // Keyboard navigation
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        this.hideLevelInfo();
                        this.hideLevelPreview();
                    }
                });
                
                // Click outside to close level info
                document.addEventListener('click', (e) => {
                    const levelInfo = document.getElementById('levelInfo');
                    const clickedDiamond = e.target.closest('.diamond');
                    
                    if (!levelInfo.contains(e.target) && !clickedDiamond) {
                        this.hideLevelInfo();
                    }
                });
                
                // Prevent level info from closing when clicking inside it
                document.getElementById('levelInfo').addEventListener('click', (e) => {
                    e.stopPropagation();
                });
            }
        }
        
        function playLevel() {
            const map = window.levelMap;
            if (map && map.selectedLevel) {
                map.playSelectedLevel();
            }
        }
        
        function goBack() {
            // Always go back to main menu (no level parameter) when using back button
            window.location.href = 'index.html';
        }
        
        function resetProgress() {
            if (confirm('Are you sure you want to reset all progress? This will clear all completed levels and start from Level 1.')) {
                ProgressManager.resetProgress();
                // Reload the page to show updated progress
                window.location.reload();
            }
        }
        
        // Initialize the level map
        window.levelMap = new LevelMap();
    </script>
</body>
</html>