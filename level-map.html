<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lily's Unicorns - Level Map</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #87CEEB 0%, #98E4FF 50%, #87CEEB 100%);
            font-family: monospace;
            color: #333;
            min-height: 100vh;
            overflow: hidden;
        }
        
        .map-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .map-canvas {
            position: relative;
            width: 800px;
            height: 600px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            overflow: hidden;
        }
        
        .diamond {
            position: absolute;
            width: 36px;
            height: 36px;
            background: linear-gradient(45deg, #FFD700, #FFA500);
            transform: rotate(45deg);
            border: 2px solid #fff;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }
        
        .diamond:hover {
            transform: rotate(45deg) scale(1.2);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.4);
            background: linear-gradient(45deg, #FFE55C, #FFB347);
        }
        
        .diamond.completed {
            background: linear-gradient(45deg, #4CAF50, #45a049);
        }
        
        .diamond.perfect {
            background: linear-gradient(45deg, #9C27B0, #7B1FA2);
        }
        
        .diamond.incomplete {
            background: linear-gradient(45deg, #FF9800, #F57C00);
        }
        
        .diamond.locked {
            background: linear-gradient(45deg, #999, #666);
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        .diamond.current {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            animation: pulse 2s infinite;
        }
        
        .diamond.selected {
            border: 4px solid #4A90E2;
            box-shadow: 0 0 20px rgba(74, 144, 226, 0.6);
        }
        
        @keyframes pulse {
            0%, 100% { transform: rotate(45deg) scale(1); }
            50% { transform: rotate(45deg) scale(1.1); }
        }
        
        .diamond-label {
            position: absolute;
            color: #fff;
            font-weight: bold;
            font-size: 14px;
            transform: rotate(-45deg);
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            pointer-events: none;
        }
        
        .connection-line {
            position: absolute;
            height: 3px;
            background: linear-gradient(90deg, rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0.4));
            z-index: 1;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            border-radius: 2px;
        }
        
        .title {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 2em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            z-index: 20;
        }
        
        .back-button {
            position: absolute;
            top: 20px;
            left: 20px;
            background: linear-gradient(45deg, #4A90E2, #357ABD);
            color: white;
            border: none;
            padding: 10px 20px;
            font-family: monospace;
            border-radius: 15px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
            z-index: 20;
        }
        
        .back-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }
        
        .level-info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 25px;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            text-align: center;
            z-index: 20;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }
        
        .level-info.show {
            opacity: 1;
            pointer-events: all;
        }
        
        .level-info.persistent {
            opacity: 1;
            pointer-events: all;
            background: rgba(255, 255, 255, 0.98);
            border: 2px solid #4A90E2;
        }
        
        .mobile-warning {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #87CEEB 0%, #98E4FF 50%, #87CEEB 100%);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
        }
        
        .mobile-warning-content {
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            font-family: monospace;
        }
        
        .legend {
            position: absolute;
            top: 80px;
            left: 20px;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            font-family: monospace;
            font-size: 12px;
            z-index: 15;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        
        .legend-diamond {
            width: 16px;
            height: 16px;
            transform: rotate(45deg);
            margin-right: 12px;
            border: 1px solid #333;
        }
        
        @media (max-width: 768px) {
            .mobile-warning {
                display: flex;
            }
            .map-container {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="mobile-warning">
        <div class="mobile-warning-content">
            <div style="font-size: 3em; margin: 20px 0;">ü¶Ñ</div>
            <h2 style="color: #4A90E2;">Computer Required</h2>
            <p>Level selection is designed for desktop use.</p>
            <div>
                <a href="index.html" style="color: #4A90E2; text-decoration: none; font-weight: bold;">‚Üê Back to Game</a>
            </div>
        </div>
    </div>

    <div class="map-container">
        <div class="title">ü¶Ñ Level Map üåà</div>
        
        <button class="back-button" onclick="goBack()">‚Üê Back to Game</button>
        
        <button class="back-button" onclick="resetProgress()" style="top: 20px; right: 20px; left: auto; background: linear-gradient(45deg, #e74c3c, #c0392b);">üîÑ Reset Progress</button>
        
        <div class="legend">
            <h4 style="margin-top: 0; color: #333;">Legend:</h4>
            <div class="legend-item">
                <div class="legend-diamond" style="background: linear-gradient(45deg, #4CAF50, #45a049); animation: pulse 2s infinite;"></div>
                <span>Current Level</span>
            </div>
            <div class="legend-item">
                <div class="legend-diamond" style="background: linear-gradient(45deg, #9C27B0, #7B1FA2);"></div>
                <span>Perfect Score (üíú)</span>
            </div>
            <div class="legend-item">
                <div class="legend-diamond" style="background: linear-gradient(45deg, #FF9800, #F57C00);"></div>
                <span>Incomplete (üß°)</span>
            </div>
            <div class="legend-item">
                <div class="legend-diamond" style="background: linear-gradient(45deg, #999, #666);"></div>
                <span>Locked</span>
            </div>
        </div>
        
        <div class="map-canvas" id="mapCanvas">
            <!-- Diamonds and connections will be generated by JavaScript -->
        </div>
        
        <div class="level-info" id="levelInfo">
            <h3 id="levelTitle">Level 1</h3>
            <p id="levelDescription">The beginning of your magical journey!</p>
            <button onclick="playLevel()" style="background: #4CAF50; color: white; border: none; padding: 8px 16px; border-radius: 8px; cursor: pointer;">Play Level</button>
        </div>
    </div>

    <script>
        // Progress tracking system (shared with game.js)
        class ProgressManager {
            static getProgress() {
                try {
                    const progress = localStorage.getItem('lily_unicorns_progress');
                    return progress ? JSON.parse(progress) : { completedLevels: [], currentLevel: 1 };
                } catch (error) {
                    console.warn('Failed to load progress:', error);
                    return { completedLevels: [], currentLevel: 1 };
                }
            }
            
            static saveProgress(progress) {
                try {
                    localStorage.setItem('lily_unicorns_progress', JSON.stringify(progress));
                } catch (error) {
                    console.warn('Failed to save progress:', error);
                }
            }
            
            static getCurrentLevel() {
                return this.getProgress().currentLevel;
            }
            
            static getCompletedLevels() {
                return this.getProgress().completedLevels;
            }
            
            static isLevelCompleted(level) {
                return this.getCompletedLevels().includes(level);
            }
            
            static isLevelPerfect(level) {
                const progress = this.getProgress();
                return progress.levelScores && progress.levelScores[level] === true;
            }
            
            static getLevelScore(level) {
                const progress = this.getProgress();
                if (!progress.levelScores || progress.levelScores[level] === undefined) {
                    return null; // Not completed yet
                }
                return progress.levelScores[level]; // true for perfect, false for incomplete
            }
            
            static resetProgress() {
                this.saveProgress({ completedLevels: [], currentLevel: 1, levelScores: {} });
            }
        }

        class LevelMap {
            constructor() {
                this.mapCanvas = document.getElementById('mapCanvas');
                this.currentLevel = ProgressManager.getCurrentLevel();
                this.completedLevels = ProgressManager.getCompletedLevels();
                this.maxLevels = 12; // Will be detected later
                this.selectedLevel = this.currentLevel;
                this.levelPositions = {};
                this.connections = [];
                
                this.init();
            }
            
            async init() {
                await this.detectMaxLevels();
                this.generateLevelPositions();
                this.createConnections();
                this.renderMap();
                this.setupEventListeners();
            }
            
            async detectMaxLevels() {
                // Try to detect available levels with extended range and better detection
                let levelNumber = 1;
                let consecutiveFailures = 0;
                const maxConsecutiveFailures = 5; // Allow gaps in level numbering
                
                while (levelNumber <= 100 && consecutiveFailures < maxConsecutiveFailures) {
                    try {
                        const response = await fetch(`levels/level${levelNumber}.json`, {
                            cache: 'no-store',
                            headers: { 'Cache-Control': 'no-cache' }
                        });
                        
                        if (response.ok) {
                            // Reset failure counter on success
                            consecutiveFailures = 0;
                            levelNumber++;
                        } else {
                            // Check embedded data as fallback
                            if (typeof LEVEL_DATA !== 'undefined' && LEVEL_DATA[levelNumber]) {
                                consecutiveFailures = 0;
                                levelNumber++;
                            } else {
                                consecutiveFailures++;
                                levelNumber++;
                            }
                        }
                    } catch (error) {
                        // Check embedded data as fallback
                        if (typeof LEVEL_DATA !== 'undefined' && LEVEL_DATA[levelNumber]) {
                            consecutiveFailures = 0;
                            levelNumber++;
                        } else {
                            consecutiveFailures++;
                            levelNumber++;
                        }
                    }
                }
                
                // The actual max level is the last successful level found
                this.maxLevels = Math.max(levelNumber - consecutiveFailures - 1, 4);
                
                // Also try to verify by checking directory listing if possible
                this.verifyLevelsExist();
            }
            
            async verifyLevelsExist() {
                // Try to get a more accurate count by checking which levels actually exist
                const existingLevels = [];
                
                for (let i = 1; i <= this.maxLevels + 10; i++) {
                    try {
                        const response = await fetch(`levels/level${i}.json`, {
                            method: 'HEAD', // Just check if file exists
                            cache: 'no-store'
                        });
                        
                        if (response.ok) {
                            existingLevels.push(i);
                        }
                    } catch (error) {
                        // Check embedded data
                        if (typeof LEVEL_DATA !== 'undefined' && LEVEL_DATA[i]) {
                            existingLevels.push(i);
                        }
                    }
                }
                
                if (existingLevels.length > 0) {
                    this.maxLevels = Math.max(...existingLevels);
                    console.log(`Detected ${existingLevels.length} levels, max level: ${this.maxLevels}`);
                    console.log('Available levels:', existingLevels);
                }
            }
            
            generateLevelPositions() {
                // Create a winding path layout like a game board
                const pathPoints = this.generatePathPoints();
                
                for (let level = 1; level <= this.maxLevels; level++) {
                    if (pathPoints[level - 1]) {
                        this.levelPositions[level] = pathPoints[level - 1];
                    }
                }
            }
            
            generatePathPoints() {
                const points = [];
                const margin = 80;
                const canvasWidth = 800;
                const canvasHeight = 600;
                const spacing = 90;
                
                // Create a winding path that fills the canvas nicely
                let x = margin;
                let y = margin;
                let direction = 1; // 1 for right, -1 for left
                let level = 0;
                
                while (y < canvasHeight - margin && level < 100) {
                    // Add points going horizontally
                    while ((direction === 1 && x < canvasWidth - margin) || 
                           (direction === -1 && x > margin)) {
                        points.push({ x, y });
                        x += spacing * direction;
                        level++;
                        
                        if (level >= 100) break;
                    }
                    
                    // Move to next row
                    y += spacing;
                    direction *= -1; // Reverse direction for next row
                    
                    // Adjust x position for the new row
                    if (direction === 1) {
                        x = margin;
                    } else {
                        x = canvasWidth - margin;
                    }
                }
                
                return points;
            }
            
            createConnections() {
                this.connections = [];
                
                // Create connections between consecutive levels
                for (let level = 2; level <= this.maxLevels; level++) {
                    const prevLevel = level - 1;
                    if (this.levelPositions[prevLevel] && this.levelPositions[level]) {
                        this.connections.push({
                            from: prevLevel,
                            to: level,
                            fromPos: this.levelPositions[prevLevel],
                            toPos: this.levelPositions[level]
                        });
                    }
                }
            }
            
            renderMap() {
                // Clear existing content
                this.mapCanvas.innerHTML = '';
                
                // Render connections first (behind diamonds)
                this.connections.forEach(conn => {
                    this.renderConnection(conn);
                });
                
                // Render diamonds
                for (let level = 1; level <= this.maxLevels; level++) {
                    if (this.levelPositions[level]) {
                        this.renderDiamond(level, this.levelPositions[level]);
                    }
                }
            }
            
            renderConnection(connection) {
                const line = document.createElement('div');
                line.className = 'connection-line';
                
                const dx = connection.toPos.x - connection.fromPos.x;
                const dy = connection.toPos.y - connection.fromPos.y;
                const angle = Math.atan2(dy, dx);
                
                // Calculate connection points at diamond edges
                const diamondRadius = 25; // Approximate radius to edge of rotated diamond
                const startX = connection.fromPos.x + Math.cos(angle) * diamondRadius;
                const startY = connection.fromPos.y + Math.sin(angle) * diamondRadius;
                const endX = connection.toPos.x - Math.cos(angle) * diamondRadius;
                const endY = connection.toPos.y - Math.sin(angle) * diamondRadius;
                
                // Calculate actual line length between diamond edges
                const actualDx = endX - startX;
                const actualDy = endY - startY;
                const length = Math.sqrt(actualDx * actualDx + actualDy * actualDy);
                
                line.style.width = `${length}px`;
                line.style.left = `${startX}px`;
                line.style.top = `${startY}px`;
                line.style.transform = `rotate(${angle}rad)`;
                line.style.transformOrigin = 'left center';
                
                this.mapCanvas.appendChild(line);
            }
            
            renderDiamond(level, position) {
                const diamond = document.createElement('div');
                diamond.className = 'diamond';
                diamond.style.left = `${position.x - 18}px`; // Center the smaller diamond
                diamond.style.top = `${position.y - 18}px`;
                diamond.dataset.level = level;
                
                // Add status classes based on actual progress
                const isCompleted = this.completedLevels.includes(level);
                const isLocked = level > this.currentLevel;
                const levelScore = ProgressManager.getLevelScore(level);
                
                if (level === this.currentLevel && !isCompleted) {
                    diamond.classList.add('current');
                } else if (isCompleted) {
                    if (levelScore === true) {
                        diamond.classList.add('perfect'); // Purple - all items collected
                    } else if (levelScore === false) {
                        diamond.classList.add('incomplete'); // Orange - missed some items
                    } else {
                        diamond.classList.add('completed'); // Green - completed before scoring system
                    }
                } else if (isLocked) {
                    diamond.classList.add('locked');
                }
                
                // Add label
                const label = document.createElement('div');
                label.className = 'diamond-label';
                label.textContent = level;
                diamond.appendChild(label);
                
                // Add click handler - either play level directly or show info
                diamond.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (isLocked) {
                        this.showLevelInfo(level, true);
                        return;
                    }
                    
                    // Double-click or already selected level plays immediately
                    if (this.selectedLevel === level) {
                        this.playSelectedLevel();
                    } else {
                        this.selectLevel(level, true);
                    }
                });
                
                // Hover behavior for preview only
                diamond.addEventListener('mouseenter', () => {
                    if (this.selectedLevel !== level) {
                        this.showLevelInfo(level, false);
                    }
                });
                
                diamond.addEventListener('mouseleave', () => {
                    if (!this.levelInfoPersistent) {
                        this.hideLevelInfo();
                    }
                });
                
                this.mapCanvas.appendChild(diamond);
            }
            
            selectLevel(level, persistent = false) {
                this.selectedLevel = level;
                this.showLevelInfo(level, persistent);
                
                // Update diamond visual selection
                this.updateDiamondSelection();
            }
            
            showLevelInfo(level, persistent = false) {
                const levelInfo = document.getElementById('levelInfo');
                const levelTitle = document.getElementById('levelTitle');
                const levelDescription = document.getElementById('levelDescription');
                
                // Update title with score status
                const levelScore = ProgressManager.getLevelScore(level);
                let titleText = `Level ${level}`;
                
                if (levelScore === true) {
                    titleText += ' üíú Perfect!';
                } else if (levelScore === false) {
                    titleText += ' üß° Incomplete';
                } else if (this.completedLevels.includes(level)) {
                    titleText += ' ‚úÖ Completed';
                }
                
                levelTitle.textContent = titleText;
                levelDescription.textContent = this.getLevelDescription(level, levelScore);
                
                // Update play button based on level status
                const playButton = levelInfo.querySelector('button');
                const isCompleted = this.completedLevels.includes(level);
                const isLocked = level > this.currentLevel;
                
                if (isLocked) {
                    playButton.textContent = 'Locked Level';
                    playButton.style.background = '#999';
                    playButton.style.cursor = 'not-allowed';
                    playButton.onclick = null;
                } else if (isCompleted) {
                    playButton.textContent = 'Replay Level';
                    playButton.style.background = '#4CAF50';
                    playButton.style.cursor = 'pointer';
                    playButton.onclick = () => this.playSelectedLevel();
                } else if (level === this.currentLevel) {
                    playButton.textContent = 'Continue Level';
                    playButton.style.background = '#ff6b6b';
                    playButton.style.cursor = 'pointer';
                    playButton.onclick = () => this.playSelectedLevel();
                } else {
                    playButton.textContent = 'Play Level';
                    playButton.style.background = '#4CAF50';
                    playButton.style.cursor = 'pointer';
                    playButton.onclick = () => this.playSelectedLevel();
                }
                
                levelInfo.classList.add('show');
                if (persistent) {
                    levelInfo.classList.add('persistent');
                    this.levelInfoPersistent = true;
                } else {
                    levelInfo.classList.remove('persistent');
                    this.levelInfoPersistent = false;
                }
                
                this.selectedLevel = level;
            }
            
            hideLevelInfo() {
                const levelInfo = document.getElementById('levelInfo');
                levelInfo.classList.remove('show', 'persistent');
                this.levelInfoPersistent = false;
            }
            
            updateDiamondSelection() {
                // Remove previous selection highlights
                this.mapCanvas.querySelectorAll('.diamond').forEach(diamond => {
                    diamond.classList.remove('selected');
                });
                
                // Add selection highlight to current diamond
                const selectedDiamond = this.mapCanvas.querySelector(`[data-level="${this.selectedLevel}"]`);
                if (selectedDiamond) {
                    selectedDiamond.classList.add('selected');
                }
            }
            
            playSelectedLevel() {
                if (this.selectedLevel && this.selectedLevel <= this.currentLevel) {
                    window.location.href = `index.html?level=${this.selectedLevel}`;
                }
            }
            
            getLevelDescription(level, levelScore = null) {
                const descriptions = {
                    1: "The beginning of your magical journey!",
                    2: "Navigate through the first challenges.",
                    3: "Trees and platforms await you.",
                    4: "Maze Runner - Find your way through!",
                    5: "Jumping puzzles and precision timing.",
                    6: "Advanced platforming challenges.",
                    7: "Dangerous swamps and careful navigation.",
                    8: "Complex multi-level structures.",
                    9: "Speed and agility required.",
                    10: "Master level precision needed."
                };
                
                let description = descriptions[level] || `Challenge level ${level} - Test your skills!`;
                
                // Add score-specific information
                if (levelScore === true) {
                    description += "\n\nüåü Perfect Score! You collected all the white and black items!";
                } else if (levelScore === false) {
                    description += "\n\n‚≠ê You completed this level but missed some items. Try again for a perfect score!";
                } else if (this.completedLevels.includes(level)) {
                    description += "\n\n‚úÖ Level completed! (Before scoring system was added)";
                }
                
                return description;
            }
            
            setupEventListeners() {
                // Keyboard navigation
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        this.hideLevelInfo();
                    }
                });
                
                // Click outside to close level info
                document.addEventListener('click', (e) => {
                    const levelInfo = document.getElementById('levelInfo');
                    const clickedDiamond = e.target.closest('.diamond');
                    
                    if (!levelInfo.contains(e.target) && !clickedDiamond) {
                        this.hideLevelInfo();
                    }
                });
                
                // Prevent level info from closing when clicking inside it
                document.getElementById('levelInfo').addEventListener('click', (e) => {
                    e.stopPropagation();
                });
            }
        }
        
        function playLevel() {
            const map = window.levelMap;
            if (map && map.selectedLevel) {
                map.playSelectedLevel();
            }
        }
        
        function goBack() {
            // Always go back to main menu (no level parameter) when using back button
            window.location.href = 'index.html';
        }
        
        function resetProgress() {
            if (confirm('Are you sure you want to reset all progress? This will clear all completed levels and start from Level 1.')) {
                ProgressManager.resetProgress();
                // Reload the page to show updated progress
                window.location.reload();
            }
        }
        
        // Initialize the level map
        window.levelMap = new LevelMap();
    </script>
</body>
</html>